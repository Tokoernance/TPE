# TPE
Test des fonctions 
import sympy as spfrom sympy.abc import ximport numpy as npfrom main_071658 import *# voici notre fichier pour l'application de nos differentes fonctions# nous allons premierement entrer notre intervale , notre marge et notre fonctiona=float(input("entrer la borne inferieure de votre intervale :"))b=float(input("entrer la borne superieure de votre intervale :"))e=float(input("entrer la marge d'erreure  :"))# nous allons maintenant entrer notre fonctionfs=input("entre la fonction f(x) ")f=sp.sympify(fs)fn=sp.lambdify([x],f,'numpy')# appelons ensuite nos fonction pour trouver une valeur approchee de racinne de 2s1=dich(fn,a,b,e)print("la solution par la methode de dichotomie est :", s1)s2=bal(fn,a,b,e)pde
 sestpare de bamethodestbalayag)print2)s3=lag(fn,a,b,e)print("la solution par la methode de lagrange est :", s3)s4=new(fn,a,e)print("la solution par la methode de newton est :", s4)istport sympy as spimport numpy as npfrom math import *# a represente la borne inferieure de notre intervale# b represente la borne superieure de notre intervale# f cest notre fonction# et e notre seuil d'erreure notre marge# methode de dichotomiedef dich(f,a,b,e):    m=e    x=a    y=b    s=x    if f(y)==0:        s = y    while abs(y-x)>=m and f(x)*f(y)<0:      s=(x+y)/2    if f(x) * f(s) <= 0:        x = s    else:        y = s    return s# methode de balayagedef bal(f, a, b, e):    m = e    x = a    y = b    while f(x) * f(x+e) > 0:         x= x+e    s=x+(e/2)    returnst
est
# methode de lagrangedef lag(f,a,b,e):    m=e    x=a    y=b    s=x    if f(y)==0:        s = y    while abs(y-x)>=m and f(x)*f(y)<0:      s=((x*f(y))-y*f(x))/(f(y)-f(x))    if f(x) * f(s) < 0:        x= s    else:        y = s    return s# methode de Newtondef new(f,a,e):    m=e    x=a    s=x    if f(s)!=0:        s = x-(f(x)/f(s))    while f(s)!=0 and abs(s-x)>=e:        x=s        s=x-(f(x)/diff(f,x))    return s
